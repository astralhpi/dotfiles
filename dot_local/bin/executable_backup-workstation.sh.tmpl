#!/bin/bash
#
# Workstation Backup Script
# 원격 워크스테이션의 여러 경로를 로컬로 백업합니다.
#

set -euo pipefail

# === 설정 ===
SSH_HOST="work"
BACKUP_PATHS="{{ .work_backup_paths }}"  # 콜론으로 구분된 원격 경로들
LOCAL_BASE="{{ .work_backup_dest }}"
LOG_FILE="$LOCAL_BASE/.backup.log"
TAILSCALE="/Applications/Tailscale.app/Contents/MacOS/Tailscale"
RSYNC="/opt/homebrew/bin/rsync"

# 로그 디렉토리 미리 생성
mkdir -p "$LOCAL_BASE"

# === 제외 목록 ===
EXCLUDES=(
    # 캐시
    '.cache'
    '.local/share/Trash'
    '.Trash'
    
    # Node.js / Bun
    'node_modules'
    '.npm'
    '.bun'
    '.pnpm-store'
    
    # Python
    '.venv'
    'venv'
    '__pycache__'
    '.mypy_cache'
    '.pytest_cache'
    '.ruff_cache'
    '.ipynb_checkpoints'
    
    # Rust
    'target'
    '.cargo/registry'
    '.cargo/git'
    '.rustup/toolchains'
    '.rustup/tmp'
    
    # Go
    'go/pkg'
    
    # Java / Kotlin
    '.gradle'
    '.m2/repository'
    'build'
    '.idea'
    
    # Elm
    'elm-stuff'
    
    # Zig
    'zig-cache'
    '.zig'
    
    # Misc
    '*.log'
    '*.tmp'
    '.DS_Store'
    'Thumbs.db'
)

# === 함수 ===
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

notify_error() {
    terminal-notifier \
        -title "Workstation Backup" \
        -message "$1" \
        -sound Basso \
        -group "backup-workstation"
}

notify_success() {
    # 성공은 조용히 (원하면 주석 해제)
    : # no-op
    # terminal-notifier \
    #     -title "Workstation Backup" \
    #     -message "$1" \
    #     -sound Glass \
    #     -group "backup-workstation"
}

check_network() {
    # expensive 네트워크 (테더링/셀룰러) 체크
    if scutil --nwi 2>/dev/null | grep -q "expensive : true"; then
        log "Expensive network detected (tethering). Skipping backup."
        exit 0
    fi
}

check_tailscale() {
    # Tailscale 연결 확인 (macOS App Store 버전)
    if ! [ -x "$TAILSCALE" ]; then
        log "Tailscale not found at $TAILSCALE. Skipping backup."
        exit 0
    fi
    
    if ! "$TAILSCALE" status &>/dev/null; then
        log "Tailscale not connected. Skipping backup."
        exit 0
    fi
}

check_host_reachable() {
    # SSH 호스트 연결 가능 여부 (타임아웃 5초)
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$SSH_HOST" "exit 0" &>/dev/null; then
        log "Host '$SSH_HOST' not reachable. Skipping backup."
        exit 0
    fi
}

backup_path() {
    local remote_path="$1"
    
    # 로컬 경로 생성: /home/jaehak -> $LOCAL_BASE/home/jaehak
    local local_path="$LOCAL_BASE$remote_path"
    mkdir -p "$local_path"
    
    # 제외 옵션 생성
    local exclude_opts=()
    for pattern in "${EXCLUDES[@]}"; do
        exclude_opts+=(--exclude="$pattern")
    done
    
    log "Backing up $SSH_HOST:$remote_path -> $local_path"
    
    # rsync 실행
    if "$RSYNC" \
        --archive \
        --compress \
        --delete \
        --delete-excluded \
        --partial \
        --human-readable \
        "${exclude_opts[@]}" \
        -e "ssh -o ConnectTimeout=30" \
        "$SSH_HOST:$remote_path/" \
        "$local_path/" \
        >> "$LOG_FILE" 2>&1; then
        log "Completed: $remote_path"
        return 0
    else
        local exit_code=$?
        log "Failed: $remote_path (exit code: $exit_code)"
        return $exit_code
    fi
}

run_backup() {
    log "=== Starting backup ==="
    
    local failed=0
    
    # 콜론으로 구분된 경로들을 순회
    IFS=':' read -ra PATHS <<< "$BACKUP_PATHS"
    for path in "${PATHS[@]}"; do
        # 빈 경로 스킵
        [[ -z "$path" ]] && continue
        
        if ! backup_path "$path"; then
            failed=1
        fi
    done
    
    if [[ $failed -eq 0 ]]; then
        log "=== All backups completed successfully ==="
        notify_success "Backup completed"
    else
        log "=== Some backups failed ==="
        notify_error "Some backups failed"
        return 1
    fi
}

# === 메인 ===
main() {
    # 전제 조건 확인
    check_network
    check_tailscale
    check_host_reachable
    
    # 백업 실행
    run_backup
}

main "$@"
